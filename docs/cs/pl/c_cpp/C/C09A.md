## Listen to WAWAWA sound everywhere

1.在C语言中，``long int``型数据在内存中的存储形式是      。
A．补码	B．反码	C．原码	D．ASCII码

!!! note 答案
    A．补码


**补码（Two's Complement）**
- 定义：补码是一种用于表示有符号整数的编码方式。它是计算机系统中最常用的整数表示法。
- 特点：补码表示法的最高位是符号位，0 表示正数，1 表示负数。正数的补码与原码相同，负数的补码是其绝对值的原码按位取反后加 1。
- 优点：补码表示法简化了计算机中的加减运算，并且解决了零的双重表示问题。    

**反码（One's Complement）**
- 定义：反码是一种用于表示有符号整数的编码方式。正数的反码与原码相同，负数的反码是其绝对值的原码按位取反
- 缺点：反码表示法存在零的双重表示问题（+0 和 -0）

**原码（Sign-Magnitude）**
- 定义：原码是一种用于表示有符号整数的编码方式。正数的原码与补码相同，负数的原码是其绝对值的二进制表示，最高位为符号位。

2.假设有定义：int k；下面程序段编译运行的情况是_____
for (k=1; k; k++)  printf ("%d ", k);
A．编译错误	
B．能运行, 是死循环
C．能运行, 正常结束	
D．以上说法都不对

!!! note 答案
    B．能运行, 是死循环
    虽然理论上 k 最终会达到 0，但在实际运行中，这个过程需要非常长的时间，因此可以认为它是一个死循环。

6.下列描述不正确的是_______
- A．外部变量定义在函数外部     
- B．局部变量定义在函数内部
- C．自动变量定义在函数内部	  
- D．静态变量定义在函数外部

!!! note 答案
    D．静态变量定义在函数外部
    **不完全正确**：静态变量可以定义在函数外部，也可以定义在函数内部。定义在函数外部的静态变量具有文件作用域，而定义在函数内部的静态变量在函数调用之间保持其值。

---

10.有如下定义，下列赋值正确的是________

```c
struct node
{
	char s[10];
	int k;
    struct node *next;
}p[5]，*q=p;

A．q.k=2	
B．p[0]->k=2 	
C．(p->s)[0]=‘a’	
D  q->s=“a”
```

!!! note 答案
    C．(p->s)[0]=‘a’
    `p` 是一个数组，`p->s` 是数组的第一个元素，`(p->s)[0]` 是数组第一个元素的第一个字符。

**Analyse**

`p`是一个包含5个`node`结构体的数组，`q`是一个指向`node`结构体的指针，指向`p`的第一个元素。

**选项分析**

- A. `q.k=2`：`q`是一个指向`struct node`的指针，不能直接访问结构体的成员，应该使用`q->k=2`

- B. `p[0]->k=2`：`p[0]`是一个`struct node`类型的元素，不是指针，不能使用箭头运算符，应该使用`p[0].k=2`

- C. `(p->s)[0]=‘a’`：`p`是一个数组，`p->s`是数组的第一个元素，`(p->s)[0]`是数组第一个元素的第一个字符。

- D. `q->s=“a”`：`q`是一个指向`struct node`的指针，不能直接赋值给一个字符数组，应该使用`strcpy(q->s, "a")`。

7.执行下面程序代码后，s值为_____。 
    
```c 
int a=1, b=2, s=0;
switch (a>b) 
{
    default: switch(s)
            {
                case 0:s+=1;
                default:s+=2;break;
            }
    case 1: s+=3; break;
}
```
!!! note 答案
    6
**Analyse**

对于外层 switch 语句的 case 1 分支

- 由于外层 switch 语句的 default 分支没有 break 语句，程序将继续执行 case 1 分支。
- 在 case 1 分支中，s += 3，所以 s 变为 6。

9.下列命令行参数程序生成的执行程序为command.exe，执行command abc 111 222<回车>，输出结果是_______。  
    
```c
# include <stdio.h>

main(int argc,char *argv[])
{
	    argc--;
while(--argc)
        printf("%s#",argv[argc]);
}
```
!!! note 答案
    111#abc#

**步骤分析**

- **命令行参数**
    - `argc`的初始值是 4（包括程序名在内的参数个数）
    - argc--后 变为 3。
    - `argv`：`["command", "abc", "111", "222"]`
- **循环**
    - 第一次循环：argc=2，输出`argv[2]`，即`111#`
    - 第二次循环：argc=1，输出`argv[1]`，即`abc#`
    - 循环结束

12.下列程序段输出
```c
int a=1;
int b=2;

void change(int *p)
{
	    int *temp=&b;
	    p=temp;
	    *p=3;
}
int main()
{
	    int *p=&a;
	    change(p);
	    printf("%d",*p);
}   
```     

!!! note 答案
    1

- `int *p = &a;：p 指向 a`
- `change(p);：调用 change 函数，传递 p 的值（即 a` 的地址）
    - 在 `change`函数中`p`被重新赋值为指向 `b，并且 b` 的值被修改为 3。
    - 但是，这并不会影响 `main 函数中的 p`，它仍然指向 `a`
- `printf("%d", *p);：输出 *p 的值，即 a 的值`    

13.用 typedef 写出类型定义,使得NEWSTR表示含有20个元素的字符数组类型

```c
typedef char NEWSTR[20];
```

14.下列程序段的输出是
```c
int  a[]={1,2,3,4,5,6,7,8,9,10,11,12},*q[4],k;

for(k=0;k<4;k++)  
    q[k]=&a[k*3];
printf("%d#",q[3][0]);
```

!!! note 答案
    10#

**步骤分析**

- `q[0] = &a[0 * 3];`   q[0] 指向 a[0]，即 1
- `q[1] = &a[1 * 3];`   q[1] 指向 a[3]，即 4
- `q[2] = &a[2 * 3];`   q[2] 指向 a[6]，即 7
- `q[3] = &a[3 * 3];`   q[3] 指向 a[9]，即 10

- `q[3] 指向 a[9]`，即 10。
- `q[3][0] 表示 q[3]` 所指向的元素，即 `a[9]`，其值为 10。


15.下列程序段执行后，z的值是
```c
static struct 
{
    int x, y[3];
} a[3] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}}, *p=&a[-1];

int z;
z=*((int *)(++p+1)-1);
```

!!! note 答案
    4