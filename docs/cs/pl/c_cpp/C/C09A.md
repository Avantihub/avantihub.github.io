## Listen to WAWAWA sound everywhere

1.在C语言中，``long int``型数据在内存中的存储形式是      。
A．补码	B．反码	C．原码	D．ASCII码

!!! note 答案
    A．补码


**补码（Two's Complement）**
- 定义：补码是一种用于表示有符号整数的编码方式。它是计算机系统中最常用的整数表示法。
- 特点：补码表示法的最高位是符号位，0 表示正数，1 表示负数。正数的补码与原码相同，负数的补码是其绝对值的原码按位取反后加 1。
- 优点：补码表示法简化了计算机中的加减运算，并且解决了零的双重表示问题。    

**反码（One's Complement）**
- 定义：反码是一种用于表示有符号整数的编码方式。正数的反码与原码相同，负数的反码是其绝对值的原码按位取反
- 缺点：反码表示法存在零的双重表示问题（+0 和 -0）

**原码（Sign-Magnitude）**
- 定义：原码是一种用于表示有符号整数的编码方式。正数的原码与补码相同，负数的原码是其绝对值的二进制表示，最高位为符号位。

2.假设有定义：int k；下面程序段编译运行的情况是_____
for (k=1; k; k++)  printf ("%d ", k);
A．编译错误	
B．能运行, 是死循环
C．能运行, 正常结束	
D．以上说法都不对

!!! note 答案
    B．能运行, 是死循环
    虽然理论上 k 最终会达到 0，但在实际运行中，这个过程需要非常长的时间，因此可以认为它是一个死循环。

6.下列描述不正确的是_______
- A．外部变量定义在函数外部     
- B．局部变量定义在函数内部
- C．自动变量定义在函数内部	  
- D．静态变量定义在函数外部

!!! note 答案
    D．静态变量定义在函数外部
    **不完全正确**：静态变量可以定义在函数外部，也可以定义在函数内部。定义在函数外部的静态变量具有文件作用域，而定义在函数内部的静态变量在函数调用之间保持其值。

---

10.有如下定义，下列赋值正确的是________

```c
struct node
{
	char s[10];
	int k;
    struct node *next;
}p[5]，*q=p;

A．q.k=2	
B．p[0]->k=2 	
C．(p->s)[0]=‘a’	
D  q->s=“a”
```

!!! note 答案
    C．(p->s)[0]=‘a’
    `p` 是一个数组，`p->s` 是数组的第一个元素，`(p->s)[0]` 是数组第一个元素的第一个字符。

**Analyse**

`p`是一个包含5个`node`结构体的数组，`q`是一个指向`node`结构体的指针，指向`p`的第一个元素。

**选项分析**

- A. `q.k=2`：`q`是一个指向`struct node`的指针，不能直接访问结构体的成员，应该使用`q->k=2`

- B. `p[0]->k=2`：`p[0]`是一个`struct node`类型的元素，不是指针，不能使用箭头运算符，应该使用`p[0].k=2`

- C. `(p->s)[0]=‘a’`：`p`是一个数组，`p->s`是数组的第一个元素，`(p->s)[0]`是数组第一个元素的第一个字符。

- D. `q->s=“a”`：`q`是一个指向`struct node`的指针，不能直接赋值给一个字符数组，应该使用`strcpy(q->s, "a")`。

7.执行下面程序代码后，s值为_____。 
    
```c 
int a=1, b=2, s=0;
switch (a>b) 
{
    default: switch(s)
            {
                case 0:s+=1;
                default:s+=2;break;
            }
    case 1: s+=3; break;
}
```
!!! note 答案
    6
**Analyse**

对于外层 switch 语句的 case 1 分支

- 由于外层 switch 语句的 default 分支没有 break 语句，程序将继续执行 case 1 分支。
- 在 case 1 分支中，s += 3，所以 s 变为 6。

9.下列命令行参数程序生成的执行程序为command.exe，执行command abc 111 222<回车>，输出结果是_______。  
    
```c
# include <stdio.h>
main(int argc,char *argv[])
{
	    argc--;
while(--argc)
        printf("%s#",argv[argc]);
}
```
!!! note 答案
    111#abc#

**步骤分析**

- **命令行参数**
    - `argc`的初始值是 4（包括程序名在内的参数个数）
    - argc--后 变为 3。
    - `argv`：`["command", "abc", "111", "222"]`
- **循环**
    - 第一次循环：argc=2，输出`argv[2]`，即`111#`
    - 第二次循环：argc=1，输出`argv[1]`，即`abc#`
    - 循环结束
