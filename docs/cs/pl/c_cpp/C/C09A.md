## Listen to WAWAWA sound everywhere

1.在C语言中，``long int``型数据在内存中的存储形式是      。
A．补码	B．反码	C．原码	D．ASCII码

!!! note 答案
    A．补码


**补码（Two's Complement）**
- 定义：补码是一种用于表示有符号整数的编码方式。它是计算机系统中最常用的整数表示法。
- 特点：补码表示法的最高位是符号位，0 表示正数，1 表示负数。正数的补码与原码相同，负数的补码是其绝对值的原码按位取反后加 1。
- 优点：补码表示法简化了计算机中的加减运算，并且解决了零的双重表示问题。    

**反码（One's Complement）**
- 定义：反码是一种用于表示有符号整数的编码方式。正数的反码与原码相同，负数的反码是其绝对值的原码按位取反
- 缺点：反码表示法存在零的双重表示问题（+0 和 -0）

**原码（Sign-Magnitude）**
- 定义：原码是一种用于表示有符号整数的编码方式。正数的原码与补码相同，负数的原码是其绝对值的二进制表示，最高位为符号位。

2.假设有定义：int k；下面程序段编译运行的情况是_____
for (k=1; k; k++)  printf ("%d ", k);
A．编译错误	
B．能运行, 是死循环
C．能运行, 正常结束	
D．以上说法都不对

!!! note 答案
    B．能运行, 是死循环
    虽然理论上 k 最终会达到 0，但在实际运行中，这个过程需要非常长的时间，因此可以认为它是一个死循环。

6.下列描述不正确的是_______
- A．外部变量定义在函数外部     
- B．局部变量定义在函数内部
- C．自动变量定义在函数内部	  
- D．静态变量定义在函数外部

!!! note 答案
    D．静态变量定义在函数外部
    **不完全正确**：静态变量可以定义在函数外部，也可以定义在函数内部。定义在函数外部的静态变量具有文件作用域，而定义在函数内部的静态变量在函数调用之间保持其值。

---

10.有如下定义，下列赋值正确的是________

```c
struct node
{
	char s[10];
	int k;
    struct node *next;
}p[5]，*q=p;

A．q.k=2	
B．p[0]->k=2 	
C．(p->s)[0]=‘a’	
D  q->s=“a”
```

!!! note 答案
    C．(p->s)[0]=‘a’
    `p` 是一个数组，`p->s` 是数组的第一个元素，`(p->s)[0]` 是数组第一个元素的第一个字符。

**Analyse**

`p`是一个包含5个`node`结构体的数组，`q`是一个指向`node`结构体的指针，指向`p`的第一个元素。

**选项分析**

- A. `q.k=2`：`q`是一个指向`struct node`的指针，不能直接访问结构体的成员，应该使用`q->k=2`

- B. `p[0]->k=2`：`p[0]`是一个`struct node`类型的元素，不是指针，不能使用箭头运算符，应该使用`p[0].k=2`

- C. `(p->s)[0]=‘a’`：`p`是一个数组，`p->s`是数组的第一个元素，`(p->s)[0]`是数组第一个元素的第一个字符。

- D. `q->s=“a”`：`q`是一个指向`struct node`的指针，不能直接赋值给一个字符数组，应该使用`strcpy(q->s, "a")`。

7.执行下面程序代码后，s值为_____。 
    
```c 
int a=1, b=2, s=0;
switch (a>b) 
{
    default: switch(s)
            {
                case 0:s+=1;
                default:s+=2;break;
            }
    case 1: s+=3; break;
}
```
!!! note 答案
    6
**Analyse**

对于外层 switch 语句的 case 1 分支

- 由于外层 switch 语句的 default 分支没有 break 语句，程序将继续执行 case 1 分支。
- 在 case 1 分支中，s += 3，所以 s 变为 6。

9.下列命令行参数程序生成的执行程序为command.exe，执行command abc 111 222<回车>，输出结果是_______。  
    
```c
# include <stdio.h>

main(int argc,char *argv[])
{
	    argc--;
while(--argc)
        printf("%s#",argv[argc]);
}
```
!!! note 答案
    111#abc#

**步骤分析**

- **命令行参数**
    - `argc`的初始值是 4（包括程序名在内的参数个数）
    - argc--后 变为 3。
    - `argv`：`["command", "abc", "111", "222"]`
- **循环**
    - 第一次循环：argc=2，输出`argv[2]`，即`111#`
    - 第二次循环：argc=1，输出`argv[1]`，即`abc#`
    - 循环结束

12.下列程序段输出
```c
int a=1;
int b=2;

void change(int *p)
{
	    int *temp=&b;
	    p=temp;
	    *p=3;
}
int main()
{
	    int *p=&a;
	    change(p);
	    printf("%d",*p);
}   
```     

!!! note 答案
    1

- `int *p = &a;：p 指向 a`
- `change(p);：调用 change 函数，传递 p 的值（即 a` 的地址）
    - 在 `change`函数中`p`被重新赋值为指向 `b，并且 b` 的值被修改为 3。
    - 但是，这并不会影响 `main 函数中的 p`，它仍然指向 `a`
- `printf("%d", *p);：输出 *p 的值，即 a 的值`    

13.用 typedef 写出类型定义,使得NEWSTR表示含有20个元素的字符数组类型

```c
typedef char NEWSTR[20];
```

14.下列程序段的输出是
```c
int  a[]={1,2,3,4,5,6,7,8,9,10,11,12},*q[4],k;

for(k=0;k<4;k++)  
    q[k]=&a[k*3];
printf("%d#",q[3][0]);
```

!!! note 答案
    10#

**步骤分析**

- `q[0] = &a[0 * 3];`   q[0] 指向 a[0]，即 1
- `q[1] = &a[1 * 3];`   q[1] 指向 a[3]，即 4
- `q[2] = &a[2 * 3];`   q[2] 指向 a[6]，即 7
- `q[3] = &a[3 * 3];`   q[3] 指向 a[9]，即 10

- `q[3] 指向 a[9]`，即 10。
- `q[3][0] 表示 q[3]` 所指向的元素，即 `a[9]`，其值为 10。


15.下列程序段执行后，z的值是
```c
static struct 
{
    int x, y[3];
} a[3] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}}, *p=&a[-1];

int z;
z=*((int *)(++p+1)-1);
```

!!! note 答案
    4

**步骤分析**
- p 被初始化为 `&a[-1]`，这是一个指向 a 数组之前位置的指针
- `++p`：将 p 增加 1,p 指向 `a[0]`
- `++p + 1`：p 指向 `a[1]`
- `(int *)(++p + 1)`：将 p 强制转换为 int 指针，指向 a[1]
- `(int *)(++p + 1) - 1`：指向 `a[1]` 的前一个 int 元素，即 `a[0].y[2]`，即 a[0] 的最后一个 int 成员,其值为 4
- 计算结果为 `z = a[0].y[2]`，即 `z = 4`

### Reading Programs

1.下列程序的输出是
```c
#include <stdio.h>
int x, y, z, w;
void p(int *y, int x)
{
    static int w;
    *y++; x++; w = x+*--y;
    printf("%d#%d#%d#%d#",x,*y,z,w);
}
int main(void)
{
    int x, y, z, w;
    x=y=z=w=1;
    do{
        static int x;
        p(&x, y);
        printf("%d#%d#%d#%d#",x,y,z,w);
    } while(0);
    return 0;
}
```

**详细分析**

**1.初始化**

- 全局变量 x, y, z, w 未初始化，默认为 0。
- 局部变量 x, y, z, w 初始化为 1。

**2.调用 `p(&x, y)` 函数**

- p 函数的参数 y 是指向局部静态变量 x 的指针，x 是局部变量 y 的值。
- `*y++`：y 指针递增，但由于 y 是局部静态变量 x 的指针，递增后指向无效地址。
- `x++`：x 递增，变为 2。
- `w = x + *--y`：y 指针递减，恢复原值，`*y` 仍然是局部静态变量 x 的值，w 变为 `2 + 0 = 2`。
- `printf("%d#%d#%d#%d#", x, *y, z, w)：输出 2#0#0#2#`。

**3.main 函数继续执行**

- `printf("%d#%d#%d#%d#", x, y, z, w)`：输出 `0#1#1#1#`

**综上所述**
``2#0#0#2#0#1#1#1#``

4.当输入：3 1 2 3 4 5 6 7 8 9 时，下列程序的输出是
```c
#include <stdio.h>        
#define N 10
void mt(int *a,int n)            
{
    int i, j, t;
    for (i=0; i<n; i++)                       
        for (j=i+1;j<n;j++) 
        {
            t=*(a+i*N+j);  
            *(a+i*N+j)=*(a+j*N+i); 
             *(a+N*j+i)=t;
        }
    return;
} 
int main()
{
	int a[N][N],n,i,j;
   	scanf("%d",&n);
	for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            scanf("%d",&a[i][j]);
    mt(&a[0][0],n);
	for(i=0;i<n;i++)
   	    for(j=0;j<n;j++)
    	        printf("%d#",a[i][j]);
    
}
```

!!! info
    注意`a[N][N]`的大小
    `*(a+i*N+j)`是`a[i][j]`的地址

**详细分析**

- mt 函数进行矩阵转置，交换矩阵的非对角线元素。

`i = 0, j = 1`：交换 `a[0][1] 和 a[1][0]`，即交换 2 和 4。
`i = 0, j = 2`：交换 `a[0][2] 和 a[2][0]`，即交换 3 和 7。
`i = 1, j = 2`：交换 `a[1][2] 和 a[2][1]`，即交换 6 和 8。

**Output**
```c
1 4 7
2 5 8
3 6 9
```

### To be continued...