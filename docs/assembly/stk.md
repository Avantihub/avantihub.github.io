## Format of the stack segment

```asm

stk segment stack;
db 200h dup('S');
stk ends

```
!!! Info
    为什么设成S?
    为了在出现一堆S时认出这是栈区，而不是数据区。

```asm

push abc[0]

Assume:
ss=1000h, sp=200h
1.sp-=2
指针向上移动两个字节，指向栈顶
2.word ptr ss:sp=abc[0]

```

## Why 段首地址必须以0结尾?

**段地址和偏移地址**

段寄存器（如 cs、ds、ss 等）存储的是段基地址的高 16 位，而段内偏移（offset）存储的是低 16 位。段基地址和段内偏移的组合形成了一个 20 位的物理地址。

在 x86 实模式下，内存地址由段地址和偏移地址组成。段地址存储在段寄存器中，偏移地址存储在通用寄存器或指令中。物理地址的计算方式如下：
```
物理地址 = 段地址 * 16 + 偏移地址
```
!!! info
    为什么段首地址必须以 0 结尾?

    由于段地址是以 16 字节为单位的，所以段地址必须是 16 的倍数，即段地址的低 4 位必须为 0。这意味着段首地址必须以 0 结尾,以确保段地址和偏移地址的组合能够正确计算物理地址。


## 理解 `cs` 和 `ip`

在 x86 汇编语言中，`cs` 和 `ip` 是两个重要的寄存器，用于管理程序的执行流。

### `cs`（Code Segment）

- **功能**：`cs` 寄存器存储代码段（Code Segment）的基地址。
- **作用**：它指示当前正在执行的代码所在的内存段的起始地址。所有指令的地址都是相对于这个段基地址计算的。

### `ip`（Instruction Pointer）

- **功能**：`ip` 寄存器存储指令指针（Instruction Pointer）。
- **作用**：它指示下一条将要执行的指令在代码段中的偏移地址。每次执行一条指令后，`ip` 会自动更新以指向下一条指令。

### `cs:ip` 组合

- **功能**：`cs:ip` 组合用于确定当前正在执行的指令的物理地址。
- **作用**：物理地址的计算方式如下：
- 物理地址 = cs * 16 + ip